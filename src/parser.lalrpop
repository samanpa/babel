#![allow(clippy)]
#![cfg_attr(feature = "cargo-clippy", allow(clippy))]
use ast::*;
use std::str::FromStr;


grammar;

//Macros
List<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


//Terminals
Num: i32 = <s:r"-?[0-9]+"> => i32::from_str(s).unwrap();
Ident: String = <r"[a-zA-Z][a-zA-Z0-9_]*'*"> => <>.to_string();

pub Module: Module = {
    <Decl+> => Module::new(<>)
};

pub Decl: Decl = {
    "extern" <name:Ident> "(" <params:List<Param>> ")" "->" <ty:Type> ";" =>
        Decl::external(name, params, ty),
    "extern" <name:Ident> "()" "->" <ty:Type> ";" =>
        Decl::external(name, vec![], ty),
    Func => { Decl::Func(<>) },
};

pub LamTyVars: Vec<String> = {
    "<" <tyvars: List<Ident>> ">" => tyvars,
                                  => vec![]
};

pub Func: LetBinding = {
    "let" <name:Ident> "(" <p:List<Ident>> ")" "{" <body: Expr> "}" => {
        LetBinding::NonRec{name,
                           expr: Expr::Lam(Box::new(Lam::new(p, body)))}
    },
    "let" <name:Ident> "()" "{" <body: Expr> "}" => {
        LetBinding::NonRec{name, expr: Expr::Lam(Box::new(Lam::new(vec![], body)))}
    }
};

pub Param: (String,Type) = {
    <id:Ident> ":" <ty:Type> => (id,ty)
};

pub Var: Expr = {
    Ident   => Expr::Var(<>),
};

pub Callee: Expr = {
    Var   => <>
};

pub Expr: Expr = {
    Num     => Expr::I32Lit(<>),
    "true"  => Expr::BoolLit(true),
    "false" => Expr::BoolLit(false),
    "()"    => Expr::UnitLit,
    Var     => <>,
    "(" <t:Expr> ")" => t,
    "if" <cond:Expr> "{" <true_expr:Expr> "}" "else" "{" <false_expr:Expr> "}"
        => Expr::If(Box::new(If::new(cond, true_expr, false_expr))),
    <callee:Callee> "(" <args:List<Expr>> ")" 
        => mk_app(callee, args),
    <callee:Callee> "()" 
        => mk_app(callee, vec![]),
    "let" <id:Ident> "=" <e1:Expr> ";" <e2:Expr>
        => Expr::Let(id, Box::new(e1), Box::new(e2)),
};

BaseType: Type = {
    "()"   => Type::Con("unit".to_string(), 0),
    Ident  => Type::Con(<>, 0)
};

Type: Type = {
    BaseType  => <>,
    ArrowType => {
        let mut params = <>;
        let retty  = params.pop().unwrap();
        make_func(params, retty)
    }
};


ArrowType: Vec<Type> = {
    <p:BaseType> "->" <r:BaseType>  => {
        vec![p, r]
    },
    <p:ArrowType> "->" <r:BaseType>  => {
        let mut p = p;
        p.push(r);
        p
    },
};

