use ast::*;
use std::str::FromStr;
use types::Type::*;
use types::Function;

grammar;

//Macros
List<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


//Terminals
Num: i32 = <s:r"-?[0-9]+"> => i32::from_str(s).unwrap();
Ident: String = <r"[a-zA-Z][a-zA-Z0-9_]*"> => <>.to_string();

pub TopLevel: TopLevel = {
    <TopDecl+> => TopLevel::new(<>)
};

pub TopDecl: TopDecl = {
    "extern" <name:Ident> "(" <params:List<Param>> ")" "->" <ty:Type> ";" =>
        TopDecl::Extern(FnProto::new(name, params, ty, vec![])),
    "extern" <name:Ident> "()" "->" <ty:Type> ";" =>
        TopDecl::Extern(FnProto::new(name, vec![], ty, vec![])),
    "use" <name:Ident> ";" => TopDecl::Use(<>),
    Lambda                 => TopDecl::Lam(<>),
};

pub LamTyVars: Vec<String> = {
    "<" <tyvars: List<Ident>> ">" => tyvars,
                                  => vec![]
};

pub Lambda: Lam = {
    "fn" <name:Ident> <tv:LamTyVars> "(" <p:List<Param>> ")" "->" <ty:Type> "{"
        <body: Expr>
     "}" => Lam::new(name, p, ty, tv, body),
    "fn" <name:Ident> <tv:LamTyVars> "()" "->" <ty:Type> "{"
        <body: Expr>
     "}" => Lam::new(name, vec![], ty, tv, body),
};

pub Param: Param = {
    <Ident> ":" <Type> => Param::new(<>)
};

pub Expr: Expr = {
    Num     => Expr::I32Lit(<>),
    "true"  => Expr::BoolLit(true),
    "false" => Expr::BoolLit(false),
    "()"    => Expr::UnitLit,
    Ident   => Expr::Var(<>, vec![]),
    <Ident> "<" <List<Type>> ">" => Expr::Var(<>),
    "(" <t:Expr> ")" => t,
    "if" <cond:Expr> "{" <true_expr:Expr> "}" "else" "{" <false_expr:Expr> "}"
        => Expr::If(Box::new(If::new(cond, true_expr, false_expr))),
    <callee:Expr> "(" <args:List<Expr>> ")"
        => Expr::App{callee: Box::new(callee), args},
};

BaseType: Type = {
    "i32"  => I32,
    "bool" => Bool,
    "()"   => Unit,
    Ident  => TyCon(<>)
};

Type: Type = {
    BaseType  => <>,
    ArrowType => <>
};

ArrowType: Type = {
    <p:Type> "->" <r:BaseType> 
        => Func(Box::new(Function::new(vec![p], r))),
    "(" <p:List<Type>> ")" "->" <r:BaseType> 
        => Func(Box::new(Function::new(p, r)))
};

