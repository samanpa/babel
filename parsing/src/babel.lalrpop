use ast::*;
use std::str::FromStr;

grammar;

//Macros
List<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};


//Terminals
Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
Ident: String = <r"[a-zA-Z][a-zA-Z0-9_]*"> => <>.to_string();

pub TopLevel : Vec<TopLevel> = {
    <TopLevelItem+> => <>
};

pub TopLevelItem: TopLevel = {
    "extern" <name:Ident> ":" <ty:ArrowType> => TopLevel::Extern{<>},
    "use" <name:Ident> ";" => TopLevel::Use{<>},
    Lambda                 => TopLevel::Lambda(Box::new(<>)),
};

pub Lambda: Lambda = {
    "fn" <name:Ident> "(" <params:List<Param>> ")" "->" <ty:Type> "{"
        <body: Expr>
     "}" => Lambda::new(name, params, ty, body),
    "fn" <name:Ident> "()" "->" <ty:Type> "{"
        <body: Expr>
     "}" => Lambda::new(name, vec![], ty, body),
};

pub Param: Param = {
    <Ident> ":" <Type> => Param::new(<>)
};

pub Expr: Expr = {
    Num     => Expr::Literal(Literal::I32(<>)),
    "true"  => Expr::Literal(Literal::Bool(true)),
    "false" => Expr::Literal(Literal::Bool(false)),
    "()"    => Expr::Literal(Literal::Unit),
    Ident   => Expr::Variable{name: <> },
    "(" <t:Expr> ")" => t,
    "if" <cond:Expr> "{" <true_expr:Expr> "}" "else" "{" <false_expr:Expr> "}"
        => Expr::IfExpr(Box::new(IfExpr::new(cond, true_expr, Some(false_expr)))),
    <callee:Expr> "(" <args:List<Expr>> ")"
        => Expr::Application{callee: Box::new(callee), args}
        
};

BaseType: Type = {
    "i32"  => Type::BaseType(BaseType::I32),
    "bool" => Type::BaseType(BaseType::Bool),
    "()"   => Type::BaseType(BaseType::Unit),
};

Type: Type = {
    BaseType  => <>,
    ArrowType => <>
};

ArrowType: Type = {
    <p:Type> "->" <r:BaseType> 
        => Type::FunctionType{ params_ty: vec![p], return_ty: Box::new(r) },
    "(" <p:List<Type>> ")" "->" <r:BaseType> 
        => Type::FunctionType{ params_ty: p, return_ty: Box::new(r) }
};

